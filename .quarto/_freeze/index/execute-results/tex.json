{
  "hash": "868f4a4f773c7bee10eaa3e6500161f2",
  "result": {
    "markdown": "# Prova 2 de Processo Estocásticos {.unnumbered}\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n## Aplicação ao modelo empírico\n\nTrata-se de um modelo para avaliar as probabilidades de transição entre os estados de precipitação de chuvas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importing data\ndados <-\n    read.delim(\"dados.txt\",\n        header = TRUE,\n        sep    = \";\"\n    ) |>\n    select(-X) |>\n    filter(!is.na(Precipitacao))\n\n# Summary statistics\ndados$Precipitacao |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   0.000   4.173   2.400 131.000 \n```\n:::\n:::\n\n\n\nO primeiro passo é discretizar a variável de precipitação, que é feita com a função `cut()` do pacote `base`. Para esse exemplo, a variável será dividida em 3 categorias: sem chuva (precipitação até $0,1$), chuva fraca (precipitação maior que $0,1$ e menor que $10$) e chuva forte.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Discretization of the variable\nquantiles <- quantile(dados$Precipitacao,\n    probs = seq(0.7, 0.9, length.out = 3)\n)\n\nbreaks <- c(-Inf, 0.001, quantiles, Inf)\n\nstate_labels <- factor(\n    c(\n        \"sem chuva\",\n        \"garoa\",\n        \"chuva fraca\",\n        \"chuva moderada\",\n        \"chuva forte\"\n    ),\n    levels = c(\n        \"sem chuva\",\n        \"garoa\",\n        \"chuva fraca\",\n        \"chuva moderada\",\n        \"chuva forte\"\n    )\n)\n\n# Discretization\ndados <-\n    dados |>\n    # Discretization\n    mutate(rain_status = cut(Precipitacao,\n        breaks = breaks,\n        labels = state_labels\n    ))\n```\n:::\n\n\nPara esse exemplo, serão separadas as 10 últimas observações para avaliar as estimações.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_teste <- tail(dados, 10)\ndados_treinamento <- dados[1:(nrow(dados) - 10), ]\n```\n:::\n\n\nPara estimar as transições de estado, é necessário criar uma variável que identifique o estado atual e o estado seguinte. Para isso, é necessário criar uma variável defasada, que pode ser feita com a função `lag()` do pacote `dplyr`. Depois disso, basta avaliar as proporções das transições de estado.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating the lagged variable\ntransicoes_chuva <-\n    dados_treinamento |>\n    # Lag variable\n    mutate(rain_status_lag = lag(rain_status)) |>\n    # Exclude the last state\n    filter(!is.na(rain_status_lag)) |>\n    # Count the transitions\n    count(rain_status, rain_status_lag) |>\n    # Calculates the estimator\n    mutate(\n        Prop = round(n / sum(n), digits = 3),\n        .by = rain_status\n    )\n```\n:::\n\n\n\n\nA matriz de transição estimada entre os estados sem chuva, garoa, chuva fraca, chuva moderada, chuva forte, nesta ordem, é dada por:\n\n\\begin{equation}\nP =\n\\begin{pmatrix}\n0.822 & 0.041 &  0.051 & 0.045 &  0.04 \\\\\n0.334 & 0.12 &  0.186 & 0.177 &  0.183 \\\\\n0.306 & 0.133 &  0.187 & 0.184 &  0.19 \\\\\n0.306 & 0.121 &  0.171 & 0.193 &  0.21 \\\\\n0.282 & 0.118 &  0.174 & 0.204 &  0.223 \n\\end{pmatrix}\n\\end{equation} \n\n\nAgora, pode-se recuperar a matriz de transição para fazer as estimativas de transição de estado.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transition matrix\nmatriz_transicao <-\n    transicoes_chuva |>\n    select(-n) |>\n    pivot_wider(\n        names_from = rain_status_lag,\n        values_from = Prop\n    ) |>\n    column_to_rownames(\"rain_status\") |>\n    as.matrix()\n\nultimo_estado <- dados_treinamento |>\n    tail(1) |>\n    pull(rain_status)\n```\n:::\n\n\n\nCom a matriz de transição, basta considerar o último estado dos dados (garoa) ---- consequência da propriedade de Markov ---- de treinamento para fazer as estimativas de transição de estado.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimula_cadeia_markov <- function(n = 10,\n                                 valor_inicial,\n                                 matriz_transicao,\n                                 estados) {\n    P <- matriz_transicao\n    y <- valor_inicial\n\n    # Simulation of the stochastic process\n    for (i in 1:n) {\n        # Sample of the next state\n        y[i + 1] <- sample(estados, size = 1, prob = P[y[i], ])\n    }\n\n    return(y[-1])\n}\n# Excecution of the function\nprevisoes <- simula_cadeia_markov(\n    valor_inicial = ultimo_estado,\n    matriz_transicao = matriz_transicao,\n    estados = state_labels,\n    n = 10\n)\n```\n:::\n\n\n\nE, então, pode-se comparar as previsões com os dados de teste. Para o gráfico, os acertos são indicados pela linha tracejada vermelha.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomparacao <-\n    data.frame(\n        observado = dados_teste$rain_status,\n        previsao = previsoes\n    )\n\n# Imprime a tabela\ncomparacao\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        observado       previsao\n1  chuva moderada chuva moderada\n2  chuva moderada    chuva fraca\n3     chuva forte chuva moderada\n4       sem chuva          garoa\n5       sem chuva    chuva fraca\n6       sem chuva      sem chuva\n7       sem chuva      sem chuva\n8       sem chuva      sem chuva\n9     chuva fraca      sem chuva\n10          garoa    chuva forte\n```\n:::\n\n```{.r .cell-code}\n# Constroi o gráfico\ncomparacao |>\n    ggplot(aes(x = observado, y = previsao)) +\n    geom_jitter(\n        size = 3, shape = 2,\n        width = 0.15, height = 0.15\n    ) +\n    geom_abline(\n        intercept = 0,\n        slope = 1,\n        color = \"red\",\n        linetype = \"dashed\"\n    ) +\n    theme_bw() +\n    labs(\n        x = \"Observado\",\n        y = \"Previsão\",\n        title = \"Previsões vs. Observações\"\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-pdf/unnamed-chunk-8-1.pdf){fig-pos='H'}\n:::\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}